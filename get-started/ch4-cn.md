# You Don't Know JS Yet: Get Started - 2nd Edition
# 第四章：更广阔的前景

本书调查了你在 *开始* 使用 JS 时需要注意的事项。我们的目标是填补那些刚接触 JS 的读者在早期接触该语言时可能被绊倒的空白。我也希望我们已经暗示了足够多的更深层次的细节，以激起你的好奇心，想要更深入地研究这门语言。

在这个系列的其他书籍中，我们将解开语言的所有其他部分，比我们在这里的几个简短章节中所能做到的要详细得多。

不过，请记住，要慢慢来。与其匆匆忙忙地进入下一本书，试图快速读完所有的书，不如花一些时间回顾一下本书的材料。再花些时间看看你当前项目中的代码，并将你所看到的与到目前为止所讨论的内容进行比较。

当你准备好了，这最后一章将 JS 语言的组织划分为三个主要支柱，然后提供了一个简短的路线图，说明对本书系列的其余部分的期望，以及我建议你如何进行。另外，不要跳过附录，特别是附录 B，“实践、实践、实践！”。

## 支柱 1：作用域和闭包

将变量组织成作用域单位（函数、块）是任何语言中最基本的特征之一；也许没有其他特征对程序的行为方式有更大的影响。

作用域就像水桶，而变量就像你放在这些水桶里的弹珠。语言的作用域模型就像帮助你确定哪种颜色的弹珠放在哪种匹配颜色的桶里的规则。

作用域相互嵌套，对于任何给定的表达式或语句，只有作用域嵌套的那一级或 更高/外侧 作用域中的变量才是可访问的；较低/内侧 作用域的变量是隐藏的，不可访问的。

这就是作用域在大多数语言中的表现，这被称为词法作用域。作用域单元的边界，以及变量在其中的组织方式，是在程序被解析（编译）时确定的。换句话说，这是一个作者时间的决定：你在程序中定位一个 函数/作用域 的位置决定了程序中这一部分的作用域结构是什么。

JS 是词法作用域，尽管许多人声称它不是，因为它的模型有两个特殊的特点，是其他词法作用域的语言所不具备的。

第一个通常被称为 *hoisting*：当所有在作用域中任何地方声明的变量都被当作在作用域的开头声明的。另一种是 “var” 声明的变量是函数作用域，即使它们出现在一个块内。

无论是提升还是函数作用域的 `var` 都不足以支持 JS 没有词法作用域的说法。`let`/`const` 声明有一个特殊的错误行为，叫做 “时间死区”（TDZ），导致可观察但不可用的变量。虽然 TDZ 的出现会很奇怪，但它 *也* 不是词法范围的无效化。所有这些都是语言的独特部分，所有 JS 开发者都应该学习和理解。

当语言将函数作为第一类值时，闭包是词法范围的自然结果，就像 JS 一样。当一个函数引用外部作用域的变量，并且该函数作为一个值在其他作用域中传递和执行时，它保持对其原始作用域变量的访问；这就是闭包。

在所有的编程中，尤其是在 JS 中，闭合驱动着许多最重要的编程模式，包括模块。在我看来，当涉及到 JS 中的代码组织时，模块是你可以得到的 *with the grain* 的东西。

要进一步了解范围、闭包和模块的工作原理，请阅读第二册《作用域与闭包》。

## 支柱 2：原型

该语言的第二个支柱是原型系统。我们在第三章（“原型”）中深入讨论了这个话题，但我只想对其重要性再做一些评论。

JS 是为数不多的几种语言之一，你可以选择直接和明确地创建对象，而不需要先在类中定义它们的结构。

多年来，人们在原型之上实现了类的设计模式 — 所谓的 “原型继承”（见附录 A，“原型 '类’”）— 然后随着 ES6 的 `class` 关键字的出现，该语言加倍倾向于 OO/类式 编程。

但我认为这种关注掩盖了原型系统的美丽和力量：两个对象能够简单地相互连接，并通过共享一个 “this” 上下文进行动态合作（在 函数/方法 执行期间）。

类只是你可以建立在这种力量之上的一种模式。但另一种方法，在一个非常不同的方向，是简单地将对象作为对象来接受，完全忘记类，让对象通过原型链进行合作。这就是所谓的 *行为委托*。我认为，作为组织程序中的行为和数据的一种手段，委托比类继承更强大。

但类的继承几乎得到了所有的关注。其余的注意力都在函数式编程（FP）上，作为设计程序的一种 “反类” 方式。这让我很难过，因为它扼杀了任何探索委托作为一种可行的替代方案的机会。

我鼓励你花大量时间深入阅读第三册 *Objects & Classes*，看看对象委托的潜力如何远远超过我们可能已经意识到的。这不是一个反 “类” 的信息，但它有意是一个 “类不是使用对象的唯一方法” 的信息，我希望更多的 JS 开发者考虑。

我想说的是，与类相比，对象委托更符合 JS 的特点（更多关于特点的内容在后面）。

## 支柱 3：类型和强制力

JS 的第三个支柱是迄今为止最被忽视的 JS 本质的一部分。

绝大多数开发者对 *类型* 在编程语言中的工作方式有强烈的误解，特别是它们在 JS 中的工作方式。在更广泛的 JS 社区中，一股兴趣浪潮已经开始转向 “静态类型” 方法，使用 TypeScript 或 Flow 等类型感知工具。

我同意 JS 开发者应该更多地了解类型，并且应该更多地了解 JS 如何管理类型转换。我也同意类型感知工具可以帮助开发者，前提是他们首先获得并使用了这些知识！

但我完全不同意这样的结论，即决定 JS 的类型机制是坏的，我们需要用语言之外的解决方案来掩盖 JS 的类型。我们不必遵循 “静态类型” 的方式，在我们的程序中聪明而扎实地使用类型。还有其他的选择，如果你愿意与众人背道而驰，与 JS 背道而驰的话（同样，更多关于这个问题的内容将在后面）。

可以说，这个支柱比其他两个更重要，因为任何 JS 程序如果不适当地利用 JS 的值类型，以及类型之间的值转换（强制），就不会做任何有用的事情。

即使你喜欢 TypeScript/Flow，如果你不深入了解语言本身是如何管理值类型的，你也不会从这些工具或编码方法中得到最大的好处。

要了解更多关于 JS 类型和强制的信息，请查看第四册，*Types & Grammar*。但是，请不要因为你总是听说我们应该使用 `===` 而忘记其他的，就跳过这个话题。

不学习这个支柱，你在 JS 中的基础是不稳固的，充其量是不完整的。

## With the Grain

在继续学习 JS 的过程中，我有一些建议要与大家分享，在这本书系列的其余部分中，你的道路也是如此：要注意 *grain*（回顾本章前面对 *grain* 的各种提及）。

首先，考虑一下大多数人如何对待和使用 JS 的 *grain*（如木材）。你可能已经注意到，这些书在很多方面都与 *grain* 相悖。在 YDKJSY 中，我尊重你这个读者，对 JS 的所有部分进行解释，而不仅仅是一些精选的流行部分。我相信你有能力也值得拥有这些知识。

但这并不是你从很多其他材料中可以找到的。这也意味着你越是遵循和坚持这些书中的指导 — 你仔细思考并为自己分析什么是你的代码中最好的 — 你就越能脱颖而出。这可能是一件好事，也可能是一件坏事。如果你想从人群中脱颖而出，你就必须从人群中脱颖而出。

但也有很多人告诉我，他们在求职面试时引用了这些书中的一些 话题/解释，而面试官告诉求职者他们错了；事实上，据说有人因此失去了工作机会。

在这些书中，我尽可能地提供关于 JS 的完全准确的信息，这些信息通常来自于规范本身。但我也在书中加入了我对如何解释和使用 JS 的意见，以便在你的程序中获得最大利益。我不会把观点当作事实，反之亦然。在这些书中，你总能知道哪个是事实。

关于 JS 的事实并没有什么可争论的。要么规范说了什么，要么没有。如果你不喜欢说明书上的内容，或者我对它的转述，请向 TC39 提出。如果你在面试时，他们声称你的事实是错误的，那么你可以当场问他们是否可以在规范中查找。如果面试官不重新考虑，那么无论如何你都不应该想在那里工作。

但是，如果你选择与我的观点保持一致，你必须准备好用你 *为什么* 这么想来支持这些选择。不要只是鹦鹉学舌，我说什么就是什么。拥有你的观点。为它们辩护。如果你希望与之合作的人不同意，请昂首挺胸地离开。这是一个很大的 JS，有很多不同的方式，有很多空间。

换句话说，不要害怕违背 *grain*，就像我在这些书和我所有的教义中所做的那样。没有人可以告诉你，你将如何最好地利用 JS；那是你自己的决定。我只是想让你有能力得出自己的结论，无论结论是什么。

另一方面，你真的应该注意并遵循一个大的 *grain*：JS 工作的 *grain*，在语言层面。有些事情在 JS 中运作得很好，很自然，只要有正确的实践和方法，有些事情你真的不应该在语言中尝试去做。

你能使你的 JS 程序看起来像一个 Java、C# 或 Perl 程序吗？那 Python 或 Ruby，甚至是 PHP 呢？在不同程度上，你当然可以。但你应该吗？

不，我不认为你应该。我认为你应该学习和接受 JS 的方式，并使你的 JS 程序尽可能地实用化。有些人会认为这意味着马虎和不正规的编程，但我完全不是这个意思。我的意思是，JS 有很多模式和习语是可以识别为 “JS” 的，而顺着这个 *grain* 的思路走是获得最佳成功的一般途径。

最后，也许最重要的是要认识到你正在开发的现有程序和与你一起工作的开发人员是如何做事的。不要读了这些书后，就想在一夜之间改变你现有项目中的 *所有 grain*。这种方法总是会失败。

你必须随着时间的推移，一点一点地改变这些东西。努力与你的同事们建立共识，了解为什么要重新审视和重新考虑一种方法。但每次只做一个小话题，让前后的代码比较来做大部分的讨论。让团队中的每个人都来讨论，并推动基于分析和代码证据的决策，而不是 “我们的高级开发人员总是这样做” 的惰性。

这是我能传授的帮助你学习 JS 的最重要建议。总是不断地寻找更好的方法来使用 JS 赋予我们的东西来编写更多的可读代码。每个在你的代码上工作的人，包括你未来的自己，都会感谢你的!

## In Order

所以，现在你已经对 JS 中剩下的内容有了更广阔的视野，也有了对待其余旅程的正确态度。

但在这个时候，我最常遇到的一个实际问题是：“我应该按什么顺序读这些书？”有一个直接的答案......但也要看情况。

我对大多数读者的建议是按照这个顺序阅读这个系列。

1. 从 *入门*（第一册）开始，打下坚实的 JS 基础 — 好消息，你已经快读完这本书了！

2.在 *作用域和闭包*（第二册）中，深入研究 JS 的第一个支柱：词法范围，它如何支持闭合，以及模块模式如何组织代码。

3. 在《对象与类》（第三册）中，重点讨论 JS 的第二个支柱：JS 的 “this” 如何工作，对象原型如何支持委托，以及原型如何使 “类” 机制用于 OO 风格的代码组织。

4. 在 *类型和语法*（第四册）中，解决 JS 的第三个也是最后一个支柱：类型和类型强制，以及 JS 的句法和语法如何定义我们如何写代码。

5. 有了 **三大支柱**，*同步与异步*（第五册）将探讨我们如何使用流控制来模拟程序中的状态变化，包括同步（立即）和异步（随时间）。

6. 本系列以 *ES.Next & Beyond*（第六册）作为结尾，对 JS 的近期和中期未来进行了展望，包括各种可能在不久之后出现在 JS 程序中的功能。

这就是阅读这一系列书籍的预期顺序。

然而，第二、三、四册通常可以按任何顺序阅读，这取决于你对哪一个主题最好奇和最愿意先探索。但我不建议你跳过这三本书中的任何一本 — 甚至是 *类型和语法*，因为你们中的一些人会想这么做！— 即使你认为你已经掌握了那个主题。

第五本书（*Sync & Async*）对深入理解 JS 至关重要，但如果你开始钻研并发现它太令人生畏，这本书可以推迟到你对这门语言更有经验时再看。你写的 JS 越多（和挣扎的越多！），你就会越欣赏这本书。所以不要害怕在以后的时间里再来读它。

该系列的最后一本书，*ES.Next & Beyond*，在某些方面是独立的。正如我所建议的那样，它可以在最后阅读，或者在《开始》之后立即阅读，如果你想找一条捷径来扩大你对 JS 的了解。这本书在未来也更有可能得到更新，所以你可能会想偶尔再看一下。

无论你选择如何进行 YDKJSY，先看看本书的附录，特别是练习附录 B 中的片段，"练习，练习，练习！" 我有没有提到你应该去练习！？没有什么比写代码更好的学习方法了。
