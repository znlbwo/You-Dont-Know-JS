# You Don't Know JS Yet: Get Started - 2nd Edition
# 第一章：什么 *是* JavaScript？

你还不了解 JS。我也不知道，反正不完全知道。我们都不知道。但是我们都可以开始更好地了解 JS。

在 *You Don't Know JS Yet*（YDKJSY）系列第一本书的第一章中，我们将花一些时间来建立一个基础，以便继续前进。我们需要从涵盖各种重要的背景内务细节开始，澄清一些关于该语言到底是什么（和不是什么！）的神话和误解。

这是对 JS 如何组织和维护的身份和过程的宝贵见解；所有 JS 开发者都应该了解它。如果你想了解 JS，这就是如何 *开始* 迈出这段旅程的第一步。

## 关于这本书

我强调旅程这个词是因为 *了解JS* 不是一个目的地，而是一个方向。无论你花多少时间来学习这门语言，你总能找到其他的东西来学习和更好地理解。所以不要把这本书看成是急于求成的东西。相反，在你迈出这最初的几步时，耐心和毅力是最好的。

在这一背景章节之后，本书的其余部分列出了你在使用 YDKJSY 书籍挖掘和学习 JS 时将会发现的高级地图。

特别是第 4 章指出了 JS 语言的三个主要支柱：作用域/闭包，原型/对象，以及类型/强制。JS 是一种广泛而复杂的语言，有许多特性和能力。但是所有的 JS 都是建立在这三个基本支柱之上的。

请记住，尽管本书的标题是 “入门”，但它 **不是作为一本 初学者/入门书**  的。本书的主要工作是让你准备好在整个系列的其余部分深入学习 JS；它的写作假设你在继续学习 YDKJSY 之前已经对 JS 有了至少几个月的熟悉经验。因此，为了从 *Get Started* 中获得最大的收获，请确保你花大量时间编写 JS 代码，以积累你的经验。

即使你以前已经写过很多 JS，这本书也不应该被略过或跳过；要花时间来充分处理这里的材料。**好的开始总是取决于坚实的第一步**。

## 这个名字是怎么回事？

JavaScript 这个名字可能是最容易被误解和误解的编程语言名称。

这种语言与 Java 有关吗？它只是 Java 的脚本形式吗？它只用于编写脚本而不是真正的程序吗？

事实是，JavaScript 这个名字是营销诡计的一个伪命题。当 Brendan Eich 第一次构思这种语言时，他把它的代码命名为 Mocha。在网景公司内部，使用的是 LiveScript 这个品牌。但是当需要公开命名该语言时，“JavaScript” “”赢得了投票。

为什么呢？因为这种语言最初是为了吸引大部分 Java 程序员的受众，而且 “脚本” 这个词在当时很流行，指的是轻量级的程序。这些轻量级的 “脚本” 将是第一个嵌入到网络这个新事物的页面中的脚本。

换句话说，JavaScript 是一种营销策略，试图将这种语言定位为一种可以替代当时更重、更知名的 Java 的语言。就这一点而言，它也可以很容易地被称为 "WebJava"。

JavaScript 的代码和 Java 代码之间有一些表面上的相似之处。这些相似之处并不特别来自于共同的开发，而是来自于两种语言都以 C 语言（以及在某种程度上 C++）的假设语法期望为目标的开发者。

例如，我们使用 `{` 来开始一个代码块，使用 `}` 来结束这个代码块，就像 C/C++ 和 Java。我们还使用 `;` 来标明语句的结束。

在某些方面，法律关系甚至比语法更深入。甲骨文公司（通过 Sun），这个仍然拥有并运行Java的公司，也拥有 “JavaScript” 这个名字的官方商标（通过 Netscape）。这个商标几乎从来没有被执行过，现在也很可能不会被执行。

由于这些原因，有人建议我们使用 JS 而不是 JavaScript。这是一个非常常见的速记方法，如果不是一个官方语言品牌的良好候选者的话。事实上，这些书几乎只用 JS 来指代该语言。

进一步将该语言与甲骨文拥有的商标拉开距离，由 TC39 指定并由 ECMA 标准机构正式确定的语言的官方名称是 **ECMAScript**。事实上，自 2016 年以来，官方语言名称也以修订年为后缀；截至本文撰写时，是 ECMAScript 2019，或其他缩写 ES2019。

换句话说，在你的浏览器或 Node.js 中运行的 JavaScript/JS，是 ES2019 标准的实现。

| 注意: |
| :--- |
| 不要使用 “JS6” 或 “ES8” 这样的术语来指代该语言。有些人这样做了，但这些术语只会使混乱永久化。你应该坚持使用 “ES20xx“ 或只是 “JS”。|

无论你叫它 JavaScript、JS、ECMAScript 还是 ES2019，它都绝对不是 Java 语言的一个变种。

> “Java 之于 JavaScript 就像火腿之于仓鼠”。— Jeremy Keith，2009 年

## 语言规范

我提到了 TC39，管理 JS 的技术指导委员会。他们的主要任务是管理该语言的官方规范。他们定期开会，对任何商定的修改进行投票，然后提交给标准组织 ECMA。

JS 的语法和行为是在 ES 规范中定义的。

ES2019 恰好是自 1995 年 JS 诞生以来的第 10 个主要编号的 规范/修订版，因此在 ECMA 主持的规范的官方 URL 中，你会发现 "10.0"。

https://www.ecma-international.org/ecma-262/10.0/

TC39 委员会由 50 到 100 名不同的人组成，这些人来自广泛的网络投资公司，如浏览器制造商（Mozilla、谷歌、苹果）和设备制造商（三星等）。委员会的所有成员都是志愿者，尽管他们中的许多人是这些公司的雇员，因此可能因其在委员会的职责而获得部分报酬。

TC39 一般每隔一个月召开一次会议，通常为期三天，以审查成员自上次会议以来所做的工作，讨论问题，并对提案进行投票。会议地点由愿意主办的成员公司轮流决定。

所有 TC39 的提案都要经过五个阶段的过程 — 当然，因为我们是程序员，所以是以 0 为基础的！— 第 0 阶段到第 4 阶段。你可以在这里阅读更多关于阶段过程的信息：https://tc39.es/process-document/

阶段 0 的意思是，TC39 的某个人认为这是一个有价值的想法，并计划支持和努力实现它。这意味着很多非 TC39 成员通过社交媒体或博客文章等非正式途径 “提出” 的想法，实际上是 "0阶段前"。你必须得到 TC39 成员的支持，它才能被正式视为 "阶段0"。

一旦一个提案达到 “第四阶段” 的状态，它就有资格被纳入下一年的语言修订中。一个提案可能需要几个月到几年的时间来完成这些阶段的工作。

所有提案都在 TC39 的 Github 资源库中公开管理：https://github.com/tc39/proposals

欢迎任何人，无论是否是 TC39 的成员，都参与这些公开讨论和提案的工作过程。但是，只有 TC39 成员可以参加会议并对提案和修改进行投票。因此，实际上，TC39 成员的声音对 JS 的发展有很大的影响。

与一些既定的、令人沮丧的神话相反，在野外不存在多个版本的 JavaScript。只有 **一个 JS**，即由 TC39 和 ECMA 维护的官方标准。

早在 21 世纪初，当微软维护一个分叉和反向工程（不完全兼容）的 JS 版本，称为 “JScript” 时，JS 的 “多版本” 是合法的。但那些日子早就过去了。今天对 JS 的这种说法已经过时了，而且不准确。

所有主要的浏览器和设备制造商都承诺使他们的 JS 实现符合这一个中央规范。当然，引擎在不同的时间实现各种功能。但是，绝对不应该出现这样的情况：V8 引擎（Chrome 的 JS 引擎）与 SpiderMonkey 引擎（Mozilla 的 JS 引擎）相比，实现的指定功能不同或不兼容。

这意味着你可以学习 **一种 JS**，并且在任何地方都可以依赖这种相同的 JS。

### 网络统治一切（JS）

虽然运行 JS 的环境阵列在不断扩大（从浏览器到服务器（Node.js），到机器人，到灯泡，到...），但统治 JS 的一个环境就是网络。换句话说，JS 如何为网络浏览器实现，在所有的实际情况下，是唯一重要的现实。

在大多数情况下，规范中定义的 JS 和基于浏览器的 JS 引擎中运行的 JS 是一样的。但也有一些必须考虑的差异。

有时 JS 规范会规定一些新的或改进的行为，但这与基于浏览器的 JS 引擎中的运行方式并不完全匹配。这种不匹配是历史遗留问题。JS 引擎已经有 20 多年的可观察行为，围绕着网络内容所依赖的功能的角落案例。因此，有时 JS 引擎会拒绝符合规范规定的变化，因为这会破坏网络内容。

在这种情况下，TC39 往往会反其道而行之，只是选择让规范符合网络的现实。例如，TC39 计划为 Arrays 增加一个 `contains(.)` 方法，但发现这个名字与一些网站上仍在使用的旧 JS 框架相冲突，所以他们把这个名字改为不冲突的 `includes(.)`。同样的情况也发生在被称为 “smooshgate” 的 喜剧/悲剧性 JS *社区危机* 中，计划中的`flatten(..)`方法最终被改名为`flat(..)`。

但偶尔，TC39 会决定规范应该在某些方面坚持到底，尽管基于浏览器的 JS 引擎不太可能符合规范。

解决办法是什么？[^specApB] JS规范包括这个附录，以详细说明官方JS规范与网络上的 JS 现实之间的任何已知不匹配。换句话说，这些是只 *允许* 网络 JS 的例外情况；其他 JS 环境必须遵守法律条文。

B.1 和 B.2 节涵盖了 JS（语法和 API）的 *补充* 内容，同样是出于历史原因，但 TC39 并不打算在 JS 的核心中正式规定这些内容。例子包括 `0` 前缀的八进制字，全局的 `escape(.)` / `unescape(.)` 工具，字符串 “helpers” 如 `anchor(.)` 和 `blink()`，以及 RegExp `compile(.)` 方法。

B.3 节包括一些冲突，在这些冲突中，代码可能同时在网络和非网络 JS 引擎中运行，但其行为 *可能* 明显不同，导致不同的结果。大多数列出的变化涉及到代码在严格模式下运行时被标记为早期错误的情况。

附录 B 中的 *gotchas* 并不经常遇到，但为了未来的安全，避免这些结构还是一个好主意。在可能的情况下，遵守 JS 规范，不要依赖只适用于某些 JS 引擎环境的行为。

### 不是所有的（网络）JS...

这段代码是一个JS程序吗？

```js
alert("Hello, JS!");
```

这取决于你如何看待问题。这里显示的 `alert(..)` 函数没有包括在 JS 规范中，但它 *在* 所有的网络 JS 环境中。然而，你不会在附录 B 中找到它，那么是什么原因呢？

各种 JS 环境（如浏览器 JS 引擎、Node.js 等）将 API 添加到你的 JS 程序的全局范围内，使你具有特定环境的能力，如能够在用户的浏览器中弹出一个警报样式的框。

事实上，一系列看起来像 JS 的 API，如 `fetch(..)`、`getCurrentLocation(..)` 和 `getUserMedia(..)`，都是看起来像 JS 的网络 API。在 Node.js 中，我们可以从各种内置模块中访问数百个 API 方法，如 `fs.write(..)`。

另一个常见的例子是 `console.log(..)`（以及所有其他的 `console.*` 方法！）。这些都不是在 JS 中指定的，但由于它们的普遍效用，几乎每个 JS 环境都根据一个大致同意的共识来定义。

所以 `alert(.)` 和 `console.log(.)` 不是由 JS 定义的。但是它们 *看起来* 像 JS。它们是函数和对象方法，它们遵守 JS 的语法规则。它们背后的行为是由运行 JS 引擎的环境控制的，但从表面上看，它们肯定要遵守 JS，才能在 JS 操场上玩耍。

人们在抱怨 “JS太不一致了！” 的时候，大多数跨浏览器的差异实际上是由于这些环境行为工作方式的不同，而不是 JS 本身的工作方式。

因此，`alert(..)` 调用 *是* JS，但 `alert` 本身实际上只是一个客人，不是官方 JS 规范的一部分。

### 它不一定是JS

在浏览器的开发工具（或 Node）中使用 控制台/REPL（读取-评估-打印-循环），乍看之下感觉是一个相当直接的 JS 环境。但实际上并非如此。

开发者工具是...开发者的工具。它们的主要目的是让开发者的生活更轻松。他们优先考虑 DX （开发者体验）。这些工具的目标并 *不是* 准确和纯粹地反映严格规范的 JS 行为的所有细微差别。因此，如果你把控制台当作一个 *纯* 的 JS 环境，有许多怪癖可能会成为 "麻烦事"。

顺便说一句，这种便利是件好事 我很高兴开发工具让开发者的生活更轻松 我很高兴我们有漂亮的用户体验符，比如 变量/属性 的自动完成，等等。我只是指出，我们不能也不应该期望这类工具 *总是* 严格遵守 JS 程序的处理方式，因为这不是这些工具的目的。

由于这类工具在不同的浏览器中的行为各不相同，而且它们的变化（有时相当频繁），我不打算将任何具体细节 “硬编码” 到本文中，从而确保这本书的文本很快就会过时。

但我只提示一些在不同的 JS 控制台环境中不同时期的怪异例子，以加强我的观点，即在使用时不要假定是原生 JS 行为。

* 控制台顶级 “全局范围” 中的 `var` 或 `function` 声明是否真的创建了一个真正的全局变量（以及镜像的 `window` 属性，反之亦然！）。

* 在顶层 “全局范围” 中的多个 `let` 和 `const` 声明会发生什么。

* `"use strict";` 在一行中（按 `<enter>` 后）是否为该控制台会话的其余部分启用严格模式，就像在 .js 文件的第一行一样，以及你是否可以在 “第一行” 之外使用 `"use strict";`，并且仍然为该会话打开严格模式。

* 非严格模式的 “this” 默认绑定如何用于函数调用，以及使用的 “全局对象” 是否会包含预期的全局变量。

* 悬挂（见第二册，*范围和闭合*）如何在多行条目中工作。

* ...其他几个

开发者控制台并不试图假装是一个 JS 编译器，它处理你输入的代码与 JS 引擎处理 .js 文件的方式完全相同。它是想让你轻松地快速输入几行代码并立即看到结果。这些是完全不同的用例，因此，期望一个工具能同样处理这两种情况是不合理的。

不要相信你在开发者控制台中看到的行为是代表 *精确* 的JS语义的；为此，请阅读规范。相反，把控制台看成是一个 “JS 友好” 的环境。这本身就很有用。

## 许多面孔

在编程语言方面，“范式” 一词指的是一种广泛的（几乎是普遍的）思维方式和结构化代码的方法。在一个范式中，有无数的风格和形式的变化来区分程序，包括无数不同的库和框架，在任何给定的代码上留下他们独特的签名。

但不管程序的个人风格如何，围绕范式的大局划分几乎总是在任何程序的第一眼就能看出来。

典型的范式级代码类别包括程序性、面向对象（OO/classes）和功能性（FP）。

* 程序化风格通过一组预先确定的操作，以自上而下的线性进展来组织代码，通常收集在一起的相关单元称为程序。

* OO 风格通过将逻辑和数据收集到称为类的单元中来组织代码。

* FP 风格将代码组织成函数（与程序相对的纯计算），并将这些函数的适应性作为值。

范式既不对也不错。它们是指导和塑造程序员如何处理问题和解决方案的方向，以及他们如何结构和维护他们的代码。

有些语言在很大程度上倾向于一种范式 — C 语言是程序化的，Java/C++ 几乎完全是面向类的，而 Haskell 则是贯穿始终的 FP。

但许多语言也支持来自不同范式的代码模式，甚至是不同范式的混合和匹配。所谓的 “多范式语言” 提供了终极的灵活性。在某些情况下，一个程序甚至可以有两个或更多的这些范式的表达方式并排存在。

JavaScript 无疑是一种多范式的语言。你可以写程序性的、面向类的或 FP 风格的代码，而且你可以在逐行的基础上做出这些决定，而不是被迫做一个全有或全无的选择。

## 向后和向前

指导 JavaScript 的最基本的原则之一是保持 *向后兼容*。许多人对这个术语的含义感到困惑，并经常将其与一个相关但不同的术语混淆。*向前兼容*。

让我们把话说清楚。

向后兼容是指一旦某样东西被接受为有效的 JS，未来就不会有语言的变化导致该代码成为无效的 JS。1995 年写的代码 — 无论它是多么原始或有限！— 今天应该仍然可以工作。正如 TC39 成员经常宣称的，"我们不会破坏网络！"

我们的想法是，JS 开发者可以放心地编写代码，他们的代码不会因为浏览器的更新发布而不可预测地停止工作。这使得为程序选择 JS 的决定在未来数年内都是更明智和安全的投资。

这种 “保证” 不是一件小事。保持向后兼容，跨越了该语言近 25 年的历史，创造了一个巨大的负担和一系列独特的挑战。你很难在计算机领域找到许多其他承诺向后兼容的例子。

坚持这一原则的代价不应该被随意忽视。它必然创造了一个非常高的门槛，包括改变或扩展语言；任何决定实际上都是永久性的，错误和所有。一旦它出现在 JS 中，就不能因为它可能会破坏程序而把它拿出来，即使我们真的很想把它拿出来！"。

这条规则也有一些小的例外。JS 有一些向后兼容的变化，但 TC39 在这样做的时候是非常谨慎的。他们研究了网络上现有的代码（通过浏览器数据收集）来估计这种破坏的影响，浏览器最终决定并投票决定他们是否愿意为一个非常小规模的破坏承受来自用户的压力，而不是为更多的网站（和用户）修复或改进语言的某些方面的好处。

这类改变是罕见的，而且几乎总是在使用的角落里，不可能在许多网站上出现明显的破坏。

比较一下 *向后兼容* 和它的对应物 *向前兼容*。向前兼容意味着在程序中加入新的语言，如果在旧的 JS 引擎中运行，不会导致该程序崩溃。**JS不是向前兼容的**，尽管许多人希望如此，甚至错误地相信它是向前兼容的神话。

相比之下，HTML 和 CSS 是向前兼容的，但不是向后兼容的。如果你挖出一些 1995 年写的 HTML 或 CSS，它完全有可能在今天无法工作（或工作方式相同）。但是，如果你在 2010 年的浏览器中使用 2019 年的新功能，页面就不会 “坏” — 未被识别的 CSS/HTML 会被跳过，而其余的 CSS/HTML 会被相应地处理。

在编程语言的设计中，似乎应该包括向前兼容，但一般来说，这样做是不现实的。标记（HTML）或造型（CSS）在本质上是声明性的，所以 “跳过” 未被识别的声明要容易得多，对其他被识别的声明的影响最小。

但是，如果一个编程语言引擎有选择地跳过它不理解的语句（甚至表达式！），就会出现混乱和非确定性，因为它不可能确保程序的后续部分不期望被跳过的部分得到处理。

尽管JS不是，也不可能是向前兼容的，但认识到JS的向后兼容是至关重要的，包括对网络的持久好处以及因此而对 JS 造成的限制和困难。

### 跳过空白点

由于 JS 不是向前兼容的，这意味着在你可以编写的有效 JS 的代码和你的网站或应用程序需要支持的最古老的引擎之间总是有可能存在差距。如果你在 2016 年的引擎中运行一个使用 ES2019 特性的程序，你很有可能看到程序中断和崩溃。

如果该特性是一种新的语法，程序一般会完全无法编译和运行，通常会抛出一个语法错误。如果该功能是一个 API（如 ES6 的 `Object.is(.)`），程序可能会运行到一个点，但一旦遇到对未知 API 的引用，就会抛出一个运行时异常并停止。

这是否意味着 JS 开发者应该永远落后于进步的步伐，只使用他们需要支持的最古老的JS引擎环境的后缘的代码？不！不！不

但它确实意味着 JS 开发者需要特别注意解决这一差距。

对于新的和不兼容的语法，解决方案是转码。转译是一个臆造的、社区发明的术语，用来描述使用一个工具将程序的源代码从一种形式转换为另一种形式（但仍为文本源代码）。通常情况下，与语法有关的向前兼容问题是通过使用转译器（最常见的是 Babel（https://babeljs.io））来解决的，即从该较新的 JS 语法版本转换为等效的旧语法。

例如，一个开发者可能会写一个代码片段，比如说

```js
if (something) {
    let x = 3;
    console.log(x);
}
else {
    let x = 4;
    console.log(x);
}
```

这就是该应用程序的源代码树中的代码的样子。但当制作文件部署到公共网站时，Babel 转码器可能会将代码转换为以下样子。

```js
var x$0, x$1;
if (something) {
    x$0 = 3;
    console.log(x$0);
}
else {
    x$1 = 4;
    console.log(x$1);
}
```

原来的片段依靠 `let` 在 `if` 和 `else` 子句中创建了块范围的 `x` 变量，这些变量不会相互干扰。Babel 能产生的等效程序（只需最小的重新工作）只是选择用唯一的名字命名两个不同的变量，产生同样的不干涉结果。

| 注意： |
| :--- |
| `let` 关键字是在 ES6（2015 年）加入的。前面的转译例子只有在应用程序需要在 ES6 之前的支持 JS 环境中运行时才需要应用。这里的例子只是为了简单说明问题。当 ES6 还是新的时候，这种转译的需求是相当普遍的，但在 2020 年，需要支持 ES6 之前的环境就不那么常见了。因此，用于转换的 “目标” 是一个滑动窗口，只有在 网站/应用程序 决定停止支持某些旧的 浏览器/引擎 时才会向上移动。|

你可能会问：为什么要麻烦地使用一个工具来从一个较新的语法版本转换到一个较旧的版本？难道我们不能直接写出这两个变量而跳过使用 `let` 关键字吗？原因是，强烈建议开发者使用最新版本的 JS，这样他们的代码才会干净，才能最有效地传达其思想。

开发者应该专注于编写干净的、新的语法形式，让工具来处理产生该代码的向前兼容的版本，该版本适合在最古老的支持的 JS 引擎环境中部署和运行。

### 填补空白

如果向前兼容的问题与新的语法无关，而是与最近才添加的缺失的 API 方法有关，那么最常见的解决方案是为缺失的 API 方法提供一个定义，就像旧环境已经有了它的原生定义一样。这种模式被称为 polyfill（又称 "shim"）。

考虑一下这段代码。

```js
// getSomeRecords() returns us a promise for some
// data it will fetch
var pr = getSomeRecords();

// show the UI spinner while we get the data
startSpinner();

pr
.then(renderRecords)   // render if successful
.catch(showError)      // show an error if not
.finally(hideSpinner)  // always hide the spinner
```

这段代码使用了 ES2019 的一个特性，即承诺原型上的 `finally(.)` 方法。如果在 ES2019 之前的环境中使用这段代码，`finally(..)` 方法将不存在，并且会出现错误。

在 ES2019 之前的环境中，对 `finally(..)` 的 polyfill 可以是这样的。

```js
if (!Promise.prototype.finally) {
    Promise.prototype.finally = function f(fn){
        return this.then(
            function t(v){
                return Promise.resolve( fn() )
                    .then(function t(){
                        return v;
                    });
            },
            function c(e){
                return Promise.resolve( fn() )
                    .then(function t(){
                        throw e;
                    });
            }
        );
    };
}
```

| 警告: |
| :--- |
| 这只是一个基本的（不完全符合规范的）polyfill 的简单说明，用于 `finally(.)`。不要在你的代码中使用这个 polyfill；尽可能地使用一个强大的、官方的 polyfill，例如 ES-Shim 中的 polyfills/shims 集合。|

`if` 语句通过防止它在任何 JS 引擎已经定义了该方法的环境中运行来保护 polyfill 的定义。在旧的环境中，polyfill 被定义，但在新的环境中，`if` 语句被悄悄地跳过。

像 Babel 这样的转码器通常会检测你的代码需要哪些 polyfills，并自动为你提供。但有时你可能需要明确地 包含/定义 它们，这与我们刚才看的片段的工作原理相似。

始终使用最合适的功能来编写代码，以有效地传达其想法和意图。一般来说，这意味着使用最新的稳定 JS 版本。避免因试图手动调整 语法/API 的差距而对代码的可读性产生负面影响。这就是工具的作用!

转化和填充是两种非常有效的技术，可以解决使用语言中最新的稳定功能的代码与网站或应用程序仍然需要支持的旧环境之间的差距。由于 JS 不会停止改进，这种差距将永远不会消失。这两种技术都应该作为每个 JS 项目的生产链的标准部分被接受，向前推进。

## 解释程序里有什么？

对于用 JS 编写的代码，有一个争论已久的问题：它是一个解释的脚本还是一个编译的程序？大多数人的看法似乎是 JS 是一种解释型（脚本）语言。但事实却比这更复杂。

在编程语言的大部分历史中，“解释” 语言和 “脚本” 语言一直被看不起，认为与它们的编译语言相比要差一些。造成这种争吵的原因很多，包括认为缺乏性能优化，以及不喜欢某些语言的特点，例如脚本语言通常使用动态类型，而不是 “更成熟” 的静态类型语言。

被认为是 “编译” 的语言通常会产生一个可移植的（二进制）程序表示，并在以后分发执行。由于我们并没有真正观察到 JS 的那种模式（我们分发的是源代码，而不是二进制形式），许多人声称这使 JS 没有资格进入这个类别。实际上，在过去的几十年里，一个程序的 “可执行” 形式的分发模式已经变得多种多样，而且也不那么重要了；就目前的问题而言，一个程序的什么形式被传递出去已经不那么重要了。

这些误导性的主张和批评应该被搁置。明确 JS 是解释的还是编译的真正原因与如何处理错误的性质有关。

从历史上看，脚本或解释语言一般是以自上而下、逐行执行的方式进行的；在开始执行之前，通常没有对程序进行初步的处理（见图1）。

<figure>
    <img src="images/fig1.png" width="650" alt="Interpreting a script to execute it" align="center">
    <figcaption><em>Fig. 1: Interpreted/Scripted Execution</em></figcaption>
    <br><br>
</figure>

在脚本语言或解释语言中，程序第 5 行的错误在第 1 至 4 行已经执行之前不会被发现。值得注意的是，第 5 行的错误可能是由于运行时的条件造成的，例如某些变量或数值不适合操作，也可能是由于该行的 语句/命令 不正确造成的。根据上下文，将错误处理推迟到错误发生的那一行可能是一个理想的或不理想的效果。

与那些在执行之前确实要经过一个处理步骤（通常称为解析）的语言相比，如图 2 所示。

<figure>
    <img src="images/fig2.png" width="650" alt="Parsing, compiling, and executing a program" align="center">
    <figcaption><em>Fig. 2: Parsing + Compilation + Execution</em></figcaption>
    <br><br>
</figure>

在这个处理模型中，第 5 行的无效命令（如语法错误）将在解析阶段被捕获，在任何执行开始之前，程序将不会运行。对于捕捉语法（或其他 "静态"）错误，一般来说，最好是在任何注定的部分执行之前知道它们。

那么，“解析” 语言与 “编译” 语言有什么共同之处呢？首先，所有的编译语言都是经过解析的。所以，解析过的语言在走向被编译的道路上已经走了很远。在经典的编译理论中，解析之后剩下的最后一步是代码生成：产生一个可执行的形式。

一旦任何源程序被完全解析，它的后续执行将以某种形式或方式包括从程序的解析形式（通常称为抽象语法树（AST））到可执行形式的翻译，这是非常常见的。

换句话说，解析语言通常在执行前也会进行代码生成，所以说在精神上，它们是编译语言也不为过。

JS 的源代码在执行之前是被解析的。规范要求如此，因为它要求在代码开始执行前报告 "早期错误” — 代码中的静态错误，如重复的参数名称。如果不对代码进行解析，这些错误就无法被识别。

那么，**JS是一种解析过的语言**，但它是 *编译* 过的吗？

答案是接近于 “是” 而不是 “不是”。经过解析的 JS 被转换为优化的（二进制）形式，然后 “代码” 被执行（图 2）；引擎在完成所有艰苦的解析工作后，通常不会切换回逐行执行（如图 1）模式 — 大多数 语言/引擎 都不会这样做，因为这样做的效率非常低。

具体来说，这种 “编译” 产生一个二进制字节码（某种意义上），然后交给 “JS虚拟机” 执行。有些人喜欢说这个虚拟机是 “解释” 字节码的。但这意味着 Java，以及其他十几种 JVM 驱动的语言，都是解释的，而不是编译的。当然，这与 Java/等 是编译语言的典型论断相矛盾。

有趣的是，虽然 Java 和 JavaScript 是非常不同的语言，但 解释/编译 的问题在它们之间却有着相当密切的联系

另一个问题是，JS 引擎可以对生成的代码进行多次 JIT（Just-In-Time）处理/优化（解析后），这也可以合理地被称为 “编译” 或 “解释”，取决于观点。实际上，在 JS 引擎的内部，这是一个非常复杂的情况。

那么，这些琐碎的细节可以归结为什么呢？退一步讲，考虑一下 JS 源程序的整个流程。

1. 在程序离开开发者的编辑器后，它被 Babel 转译，然后被 Webpack 打包（也许还有其他半打的构建过程），然后它以非常不同的形式交付给JS引擎。

2. JS 引擎将代码解析为 AST。

3. 然后引擎将 AST 转换为一种字节码，即二进制中间表示（IR），然后由优化的 JIT 编译器进一步 完善/转换。

4. 最后，JS 虚拟机执行程序。

为了使这些步骤可视化，再次。

<figure>
    <img src="images/fig3.png" width="650" alt="Steps of JS compilation and execution" align="center">
    <figcaption><em>Fig. 3: Parsing, Compiling, and Executing JS</em></figcaption>
    <br><br>
</figure>

JS 的处理方式是像图 1 那样，更像一个解释的、逐行的脚本，还是更像一个编译的语言，在执行前先进行一到几次处理（如图 2 和图 3）？

我认为很明显，在精神上，如果不是在实践中，**JS是一种编译语言**。

再说一遍，重要的原因是，由于 JS 是编译的，在我们的代码被执行之前，我们会被告知静态错误（如畸形的语法）。这与我们在传统的 “脚本” 程序中得到的互动模式有很大的不同，可以说是更有帮助的

### 网络装配 (WASM)

推动 JS 发展的一个主要问题是性能，包括 JS 的 解析/编译 速度和编译后的代码执行速度。

2013 年，Mozilla Firefox 的工程师展示了将虚幻 3 游戏引擎从 C 语言移植到 JS 的过程。这段代码能够以 60fps 的性能在浏览器的 JS 引擎中运行，是以 JS 引擎能够进行的一系列优化为前提的，因为虚幻引擎的 JS 版本的代码使用了一种偏爱JS语言子集的代码风格，命名为 "ASM.js"。

这个子集是以在正常编码中有些不常见的方式编写的有效 JS，但是它向引擎发出了某些重要的类型化信息的信号，使它可以进行关键的优化。ASM.js 是作为解决 JS 运行时性能的压力的一种方式被引入的。

但需要注意的是，ASM.js 从未打算成为开发人员编写的代码，而是从另一种语言（如 C）转换而来的程序的代表，其中这些类型的 “注释” 是由工具自动插入的。

在 ASM.js 证明了工具创建的程序版本可以被 JS 引擎更有效地处理的有效性之后几年，另一组工程师（最初也来自 Mozilla）发布了 Web Assembly（WASM）。

WASM 与 ASM.js 类似，它的初衷是为非 JS 程序（C 等）提供一个路径，将其转换为可以在 JS 引擎中运行的形式。与 ASM.js 不同的是，WASM 选择在程序执行前额外绕过 JS 解析/编译 中的一些固有延迟，以一种完全不同于 JS 的形式表示程序。

WASM 是一种更类似于汇编的表示格式（因此，它的名字），可以被 JS 引擎处理，跳过 JS 引擎通常进行的 解析/编译。WASM 目标程序的 解析/编译 是提前进行的（AOT）；分发的是一个二进制打包的程序，JS 引擎可以用最少的处理来执行。

WASM 的一个最初动机显然是潜在的性能改进。虽然这仍然是一个重点，但 WASM 的另一个动机是希望为网络平台带来更多非 JS 语言的平等性。例如，如果像 Go 这样的语言支持线程编程，但 JS（语言）不支持，那么 WASM 就有可能将这样的 Go 程序转换为 JS 引擎能够理解的形式，而不需要 JS 语言本身的线程功能。

换句话说，WASM 减轻了为 JS 添加功能的压力，这些功能 主要/完全 是为了被其他语言的转置程序所使用。这意味着 JS 的功能开发可以（由 TC39）进行判断，而不会被其他语言生态系统的 兴趣/需求 所歪曲，同时仍然让这些语言在网络上有一个可行的路径。

另一个正在出现的关于 WASM 的观点，有趣的是，甚至与网络（W）没有直接关系。WASM 正在发展成为一种跨平台的虚拟机（VM），程序可以被编译一次并在各种不同的系统环境中运行。

所以，WASM 并不只适用于网络，而且 WASM 也不是 JS。具有讽刺意味的是，尽管 WASM 在 JS 引擎中运行，但 JS 语言是最不适合用于 WASM 程序源的语言之一，因为 WASM 严重依赖静态类型化信息。即使是 TypeScript（TS）— 可能是 JS+ 静态类型 — 也不太适合（就目前而言）转译到 WASM，尽管像 AssemblyScript 这样的语言变体正试图弥补 JS/TS 和 WASM 之间的差距。

这本书不是关于 WASM 的，所以我不会花更多的时间来讨论它，只是想说明最后一点。*有些人* 认为 WASM 指向一个未来，即 JS 从网络中被删除，或被最小化。这些人通常对 JS 怀有恶感，并希望有其他语言 — 任何其他语言！— 来取代它。由于 WASM 允许其他语言在 JS 引擎中运行，从表面上看这并不是一个完全幻想的童话。

但让我简单地说明一下。WASM 不会取代JS。WASM 大大增强了网络（包括 JS）所能完成的工作。这是一件伟大的事情，与一些人是否会把它作为逃避编写 JS 的借口完全无关。

## *严格* 说

早在 2009 年，随着 ES5 的发布，JS 增加了 *严格模式*，作为一种鼓励更好的 JS 程序的选择机制。

严格模式的好处远远大于成本，但旧习难改，现有（又称 "遗留"）代码库的惯性真的很难改变。因此，可悲的是，10 多年过去了，严格模式的 *可选择性* 意味着它仍然不一定是 JS 程序员的默认模式。

为什么是严格模式？严格模式不应该被认为是对你不能做什么的限制，而应该被认为是对做事的最佳方式的指导，这样 JS 引擎就有了优化和有效运行代码的最佳机会。大多数 JS 代码都是由开发人员组成的团队完成的，所以严格模式的 *严格* 性（以及像 linters 这样的工具！）往往有助于代码的协作，避免了一些在非严格模式下容易出现的问题。

大多数严格模式的控制都是以 *早期错误* 的形式出现的，也就是说，那些严格意义上的语法错误在编译时（代码运行前）仍会被抛出。例如，严格模式不允许将两个函数参数命名为相同的参数，这将导致一个早期错误。其他一些严格模式的控制只有在运行时才能观察到，比如 `this` 默认为 `undefined` 而不是全局对象。

与其和严格模式争论不休，就像一个只想违抗父母告诉他们不要做的事情的孩子，最好的心态是，严格模式就像一个提醒你JS*应该如何编写以获得最高质量和最佳性能的 interter。如果你发现自己感到束手束脚，试图绕过严格模式工作，这应该是一个响亮的红色警告标志，说明你需要后退并重新思考整个方法。

严格模式是通过一个特殊的编译指示来开启每个文件的（除了 注释/空白 外，在它之前不允许有任何东西）。

``js
// 只允许使用空白和注释
// 在使用严格编译指示之前
"use strict”;
// 文件的其余部分以严格模式运行
```

| 警告： |
| :--- |
| 需要注意的是，即使在严格模式编译指示之前出现一个游离的 `;`，也会使编译指示失去作用；不会出现错误，因为在语句位置有一个字符串字面表达式是有效的 JS，但它也会默默地 *不* 开启严格模式 |

严格模式也可以在每个函数范围内开启，对其周围的规则完全相同。

``js
function someOperations() {
    // 这里可以使用空白和注释
    "use strict”;

    // 所有这些代码将在严格模式下运行
}
```

有趣的是，如果一个文件开启了严格模式，那么函数级的严格模式谚语是不允许的。所以你必须二选一。

在每个函数方法内使用严格模式的 **唯一** 理由是当你正在转换一个现有的非严格模式程序文件，并且需要在一段时间内一点一点地进行修改。否则，直接为整个 文件/程序 打开严格模式会好得多。

许多人想知道，是否会有一天 JS 将严格模式作为默认模式？答案是，几乎肯定不会。正如我们之前讨论的关于向后兼容性的问题，如果 JS 引擎的更新开始假定代码是严格模式，即使它没有被标记为严格模式，那么这些代码有可能因为严格模式的控制而被破坏。

然而，有几个因素可以减少严格模式这种非默认的 “隐蔽性” 的未来影响。

首先，几乎所有转置的代码最终都会进入严格模式，即使原始的源代码并没有这样写。生产中的大多数 JS 代码已经被转码，所以这意味着大多数 JS 已经遵守了严格模式。撤销这一假设是有可能的，但你必须走出去才行，所以这是很不可能的。

此外，一个广泛的转变正在发生，即 更多/大多数 新的 JS 代码正在使用 ES6 模块格式编写。ES6 模块假定为严格模式，因此此类文件中的所有代码都自动默认为严格模式。

综上所述，严格模式在很大程度上是事实上的默认模式，尽管技术上它实际上不是默认的。

## 已定义

JS 是 ECMAScript 标准的一个实现（截至本文撰写时为 ES2019 版本），由 TC39 委员会指导，ECMA 主办。它在浏览器和其他 JS 环境中运行，如 Node.js。

JS 是一种多范式语言，这意味着其语法和功能允许开发人员混合和匹配（以及弯曲和重塑！）来自各种主要范式的概念，如面向过程、面向对象（OO/类）和函数式（FP）。

JS 是一种编译语言，意味着工具（包括JS引擎）在程序执行前会对其进行处理和验证（报告任何错误！）。

现在我们的语言已经 *定义* 了，让我们开始了解它的内涵和外延。

[^specApB]: ECMAScript 2019 语言规范，附录 B：网络浏览器的附加 ECMAScript 功能，https://www.ecma-international.org/ecma-262/10.0/#sec-additional-ecmascript-features-for-web-browsers（截至本文撰写时的最新版本，即 2020 年 1 月）
